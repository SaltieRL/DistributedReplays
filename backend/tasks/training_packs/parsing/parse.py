import io
import json
import struct
from typing import List

from backend.tasks.training_packs.parsing.binary_reader import BinaryReader


class TrainingPack:
    GUID = None


def pack_string(s):
    byte_type_length = struct.pack("<I", len(s) + 1)
    byte_type = bytes(s.encode() + '\x00'.encode())
    return byte_type_length + byte_type


class Property:
    property_type = "StructProperty"
    name = ""
    value = None

    def __init__(self, property_type, name, value):
        self.property_type = property_type
        self.name = name
        self.value = value

    def serialize(self):
        name_length = struct.pack("<I", len(self.name) + 1)
        name = bytes(self.name.encode() + '\x00'.encode())

        type_length = struct.pack("<I", len(self.property_type) + 1)
        property_type = bytes(self.property_type.encode() + '\x00'.encode())

        if self.property_type == "IntProperty":
            value = struct.pack("<Q", self.value)
        elif self.property_type == "ByteProperty":

            first_value = struct.pack("<Q", self.value[1])
            byte_type = pack_string(self.value[0])
            byte_value = pack_string(self.value[2])

            value = first_value + byte_type + byte_value
        elif self.property_type == "BoolProperty":
            value = struct.pack("?", self.value)
        elif self.property_type == "FloatProperty":
            value = struct.pack("<Q", 4) + struct.pack("<f", self.value)
        elif self.property_type == "StrProperty" or self.property_type == "NameProperty":
            value = struct.pack("<Q", len(self.value) + 1 + 4) + struct.pack("<I", len(self.value) + 1) + bytes(
                self.value.encode() + '\x00'.encode())
            # the long (<Q) in this area is some sort of value (0b) that isn't clear what it means
            # seems to be len(self.value) + 1 + 4
        elif self.property_type == "ObjectProperty":
            value = bytes([
                0x0d, 0x00, 0x00, 0x00, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x44, 0x61, 0x74, 0x61,
                0x00, 0x0f, 0x00, 0x00, 0x00, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x50, 0x72, 0x6f, 0x70, 0x65,
                0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x05, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x6e, 0x65, 0x00, 0xff, 0xff, 0xff, 0xff])
            name_length = bytes()
            name = bytes()
            type_length = bytes()
            property_type = bytes()
            # just reset all of these since we can't accurately represent this
        elif self.property_type == "ArrayProperty":
            # OUTSIDE ARRAY
            # rounds = pack_string("Rounds")
            # type_ = pack_string("ArrayProperty")

            elements = struct.pack("<I", len(self.value))
            shots = bytes()
            for shot in self.value:
                time_limit = shot['TimeLimit'].serialize()

                serialized_archtypes = pack_string("SerializedArchetypes")
                arrayproperty = pack_string("ArrayProperty")

                shot_data = bytes()

                for obj in shot['data']:
                    if obj is None:
                        jsn_str = pack_string("None")
                    else:
                        json_dump = json.dumps(obj, separators=(',', ':'))

                        jsn_str = pack_string(json_dump)

                    shot_data += jsn_str
                size2 = struct.pack("<Q", len(shot_data))
                elements2 = struct.pack("<I", len(shot['data']) - 1)
                shots += time_limit + serialized_archtypes + arrayproperty + size2 + elements2 + shot_data

            extra = bytes([
                0x05, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x6e, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00,
                0x00, 0x54, 0x41, 0x47, 0x61, 0x6d, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67,
                0x45, 0x64, 0x69, 0x74, 0x6f, 0x72, 0x44, 0x61, 0x74, 0x61, 0x5f, 0x54, 0x41, 0x00, 0x41, 0x00,
                0x00, 0x00
            ])
            size = struct.pack("<Q", len(shots))
            value = size + elements + shots + extra
            # length =

        elif self.property_type == "StructProperty":
            length_struct_value = struct.pack("<Q", len(self.value[1]) // 2)
            length_struct_type = struct.pack("<I", len(self.value[0]) + 1)
            value = length_struct_value + length_struct_type + bytes(
                self.value[0].encode() + '\x00'.encode()) + bytes.fromhex(
                self.value[1])

        return name_length + name + type_length + property_type + value

    def __repr__(self):
        return "<{} {} {}>".format(self.property_type, self.name, self.value)


class StructProperty(Property):
    @staticmethod
    def read(reader):
        length_of_property = reader.ReadUInt64()
        length_of_struct = reader.ReadUInt32()
        struct_name = reader.ReadFixedString(length_of_struct).decode()
        value = reader.ReadBytes(length_of_property)
        string_value = ""
        for i in range(4):
            string_value += value[i * 4: (i + 1) * 4][::-1].hex()
        value = value.hex()
        return struct_name, value, string_value


def parse_header(reader: BinaryReader):
    foosball = reader.ReadUInt32()
    extra = reader.ReadUInt32()
    extra2 = reader.ReadUInt32()
    extra3 = reader.ReadUInt32()
    extra4 = reader.ReadUInt32()
    extra5 = reader.ReadUInt32()
    extra6 = reader.ReadUInt32()


def read_property(reader: BinaryReader):
    try:
        property_name = reader.ReadString()
    except:
        return None
    if property_name == "None":
        reader.ReadUInt32()
        return Property(None, property_name, None)
    elif property_name == '':
        return None
    elif property_name == 'TAGame.TrainingEditorData_TA':
        return None
    property_type = reader.ReadString()

    if property_type == "StructProperty":
        value = StructProperty.read(reader)
    elif property_type == "ObjectProperty":
        value = read_objectproperty(reader)
    elif property_type == "StrProperty":
        value = read_strproperty(reader)
    elif property_type == "ByteProperty":
        byte_value, byte_type, value = read_byteproperty(reader)
        value = (byte_type, byte_value, value)
    elif property_type == "NameProperty":
        value = read_strproperty(reader)
    elif property_type == "BoolProperty":
        value = read_boolproperty(reader)
    elif property_type == "IntProperty":
        value = read_intproperty(reader)
    elif property_type == "FloatProperty":
        value = read_floatproperty(reader)
    elif property_type == "ArrayProperty":
        value = read_arrayproperty(reader)
    elif property_name == "ETrainingType":
        value = property_type
    elif property_name == "EDifficulty":
        value = property_type
    else:
        raise Exception("Unknown property type " + property_type)
    return Property(name=property_name, property_type=property_type, value=value)


def read_objectproperty(reader):
    length = reader.ReadInt32()
    extra = reader.ReadInt64()

    return ""


def read_special(reader):
    length = reader.ReadUInt32()
    # padding = reader.ReadBytes(3)
    value = reader.ReadFixedString(length)
    gibberish = reader.ReadBytes(4)
    return value


def read_byteproperty(reader):
    # something more complicated
    value = reader.ReadInt64()
    type = reader.ReadString()
    name = reader.ReadString()
    return value, type, name


def read_boolproperty(reader):
    return reader.ReadBool()


def read_intproperty(reader):
    return reader.ReadUInt64()


def read_floatproperty(reader):
    reader.ReadUInt64()
    return reader.ReadFloat()


def read_arrayproperty(reader):
    length = reader.ReadUInt64()
    elements = reader.ReadUInt32()

    data = []
    for i in range(elements):
        shot = {}
        time_limit = read_property(reader)
        shot[time_limit.name] = time_limit
        part1 = reader.ReadString()

        if part1 == 'TAGame.TrainingEditorData_TA':
            # we're done here
            break
        part2 = reader.ReadString()

        # nested
        length = reader.ReadUInt64()
        some_other_value = reader.ReadUInt32()
        part1 = reader.ReadString()
        part2 = reader.ReadString()
        part3 = reader.ReadString()
        part4 = reader.ReadString()

        ball_info = load_json(part1)
        car_info = load_json(part2)
        part_3_json = load_json(part3)
        part_4_json = load_json(part4)
        # raise NotImplementedError("Array type not yet implemented")
        shot['data'] = [ball_info, car_info, part_3_json, part_4_json]
        data.append(shot)
        # print(ball_info)
    return data


def load_json(value):
    if value == 'None':
        return None
    return json.loads(value)


def read_strproperty(reader):
    value = reader.ReadUInt64()
    # padding = reader.ReadBytes(padding_till_string_start - 4)
    string_length = reader.ReadUInt32()
    # padding = reader.ReadBytes(3)
    string_value = reader.ReadFixedString(string_length)
    return string_value.decode()


header = bytes([
    0x11, 0xba, 0x05, 0xf0, 0xff, 0xff, 0xff, 0x7f, 0x64, 0x03, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff
])


def parse(bts):
    reader = BinaryReader(io.BufferedReader(bts))
    parse_header(reader)  # does nothing currently
    data = []
    while True:
        value = read_property(reader)
        if value is None:
            break
        data.append(value)
    return data


def serialize(properties: List[Property]):
    recreated = header

    for prop in properties:
        try:
            recreated += prop.serialize()
        except Exception as e:
            # print("Error serializing prop:", prop, e)
            pass
    # recreated += part2
    recreated = bytearray(recreated)
    size = struct.pack("<I", len(recreated) - 61)
    for i in range(20, 24):
        recreated[i] = size[i - 20]

    return bytes(recreated)


# no idea what this does but it's part of every replay file
part2 = bytes([
    0x07, 0x00, 0x00, 0x00, 0x52, 0x6f, 0x75, 0x6e, 0x64, 0x73, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x41,
    0x72, 0x72, 0x61, 0x79, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0xa8, 0x02, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x54, 0x69, 0x6d,
    0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x46, 0x6c, 0x6f, 0x61, 0x74,
    0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x20, 0x41, 0x15, 0x00, 0x00, 0x00, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69,
    0x7a, 0x65, 0x64, 0x41, 0x72, 0x63, 0x68, 0x65, 0x74, 0x79, 0x70, 0x65, 0x73, 0x00, 0x0e, 0x00,
    0x00, 0x00, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
    0x3c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00,
    0x7b, 0x22, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x41, 0x72, 0x63, 0x68, 0x65, 0x74, 0x79, 0x70,
    0x65, 0x22, 0x3a, 0x22, 0x41, 0x72, 0x63, 0x68, 0x65, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x42,
    0x61, 0x6c, 0x6c, 0x2e, 0x42, 0x61, 0x6c, 0x6c, 0x5f, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x64, 0x69,
    0x74, 0x6f, 0x72, 0x22, 0x2c, 0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x6f, 0x63, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x58, 0x22, 0x3a, 0x2d, 0x31, 0x38, 0x32, 0x2e, 0x33, 0x31, 0x39, 0x32, 0x2c,
    0x22, 0x53, 0x74, 0x61, 0x72, 0x74, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x59, 0x22,
    0x3a, 0x34, 0x30, 0x33, 0x39, 0x2e, 0x36, 0x35, 0x35, 0x35, 0x2c, 0x22, 0x53, 0x74, 0x61, 0x72,
    0x74, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x22, 0x3a, 0x32, 0x36, 0x32, 0x2e,
    0x31, 0x34, 0x32, 0x35, 0x2c, 0x22, 0x56, 0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79, 0x53, 0x74,
    0x61, 0x72, 0x74, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x22, 0x3a, 0x38, 0x31,
    0x30, 0x30, 0x2c, 0x22, 0x56, 0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79, 0x53, 0x74, 0x61, 0x72,
    0x74, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x59, 0x22, 0x3a, 0x2d, 0x31, 0x34, 0x32,
    0x38, 0x37, 0x2c, 0x22, 0x56, 0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79, 0x53, 0x74, 0x61, 0x72,
    0x74, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x22, 0x3a, 0x2d, 0x38, 0x32, 0x38,
    0x2c, 0x22, 0x56, 0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79, 0x53, 0x74, 0x61, 0x72, 0x74, 0x53,
    0x70, 0x65, 0x65, 0x64, 0x22, 0x3a, 0x31, 0x34, 0x33, 0x39, 0x2e, 0x38, 0x35, 0x34, 0x31, 0x7d,
    0x00, 0xaa, 0x00, 0x00, 0x00, 0x7b, 0x22, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x41, 0x72, 0x63,
    0x68, 0x65, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x41, 0x72, 0x63, 0x68, 0x65, 0x74, 0x79,
    0x70, 0x65, 0x73, 0x2e, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x64, 0x69, 0x74, 0x6f, 0x72, 0x2e, 0x44,
    0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x50, 0x6f, 0x69, 0x6e, 0x74,
    0x4d, 0x65, 0x73, 0x68, 0x22, 0x2c, 0x22, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x58,
    0x22, 0x3a, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x2c, 0x22, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x59, 0x22, 0x3a, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x30, 0x2c, 0x22, 0x4c, 0x6f, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x22, 0x3a, 0x32, 0x39, 0x2e, 0x39, 0x39, 0x35, 0x35, 0x2c,
    0x22, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x22, 0x3a, 0x30, 0x2c, 0x22, 0x52,
    0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x59, 0x22, 0x3a, 0x31, 0x36, 0x33, 0x38, 0x34, 0x2c,
    0x22, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x22, 0x3a, 0x30, 0x7d, 0x00, 0x81,
    0x00, 0x00, 0x00, 0x7b, 0x22, 0x49, 0x73, 0x50, 0x43, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c,
    0x22, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x58, 0x22, 0x3a, 0x2d, 0x35, 0x39, 0x39,
    0x2e, 0x39, 0x39, 0x39, 0x39, 0x2c, 0x22, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x59,
    0x22, 0x3a, 0x2d, 0x37, 0x30, 0x30, 0x2e, 0x30, 0x30, 0x30, 0x31, 0x2c, 0x22, 0x4c, 0x6f, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5a, 0x22, 0x3a, 0x35, 0x32, 0x39, 0x2e, 0x39, 0x39, 0x35, 0x35,
    0x2c, 0x22, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x22, 0x3a, 0x2d, 0x31, 0x39,
    0x35, 0x32, 0x2c, 0x22, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x59, 0x22, 0x3a, 0x31,
    0x34, 0x30, 0x33, 0x37, 0x2c, 0x22, 0x52, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x22,
    0x3a, 0x30, 0x7d, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x6e, 0x65, 0x00, 0x05, 0x00, 0x00,
    0x00, 0x4e, 0x6f, 0x6e, 0x65, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x54, 0x41,
    0x47, 0x61, 0x6d, 0x65, 0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x45, 0x64, 0x69,
    0x74, 0x6f, 0x72, 0x44, 0x61, 0x74, 0x61, 0x5f, 0x54, 0x41, 0x00, 0x41, 0x00, 0x00, 0x00
])
